p1
without strrev 
Step 1. Read String A and declare variable temp of type char.
Step 2. Set I:=0, J=strlen(A)-1.
Step 3. Repeat steps 4 &amp; 5 while I&lt;=J
Step 4. Set temp := A[I]
Set A[I] := A[J]
Set A[J] := temp
Step 5. Set I:=I+1, J:=J-1
Step 6. Exit and return.


program
include<stdio.h>
#include<string.h>
int main()
{char a[20],b[20],c[20],temp;
int l,i,j;
printf("\n Enter the First String");
scanf("%s",a);
printf("\n Enter the Second String");
scanf("%s",b);
l=strlen(a);
printf("\n Length of First String is %d",l);
strcat(a,b);
printf("\n Concatenation of String a & String b is %s", a);
strcpy(c,a);
printf("\n Copied String is %s",c);
i=0;
j=strlen(a)-1;
while(i<j)
{temp=a[i];
a[i]=a[j];
a[j]=temp;
i++;
j--; }
printf("\n Reverse of original string is %s : \n ", a); }









p1B
#include<stdio.h>
#include<string.h>
void main()
{char str[20];
char a[]="aeiouAEIOU";
int i,j,count=0;
printf("Enter the String... \n");
gets(str);
for(i=0;str[i]!='\0';i++)
{for(j=0;a[j]!='\0';j++)
{if(a[j]==str[i])
{count++;
break;} }}
printf("Vowels present in tne string are: %d \n",count);}





p2
(Linear search) LINEAR (DATA, N, ITEM, LOC), here DATA is a linear array with N elements, and
ITEM is a given item of information. This algorithm finds the location LOC of ITEM in DATA, or
sets LOC: =0 if the search is unsuccessful.
1. [Insert ITEM at the end of DATA.] Set DATA [N+1]:= ITEM.
2. [Initialize counter.] Set LOC: =1.
3. [Search for ITEM.]
Repeat while DATA [LOC]! =ITEM:
Set LOC: =LOC+1
[End of loop]
4. [Successful?] If LOC= N+1, then: Set LOC: =0.
5. Exit


program

PRACTICAL 2
#include<stdio.h>
int main()
{int a[20],i,item,n,flag=0;
printf("\n Enter the number of elements in array");
scanf("%d",&n);

printf("\n Enter %d Elements ",n);
for(i=1;i<=n;i++)
scanf("%d", &a[i]);
printf("\nEnter the element to search");
scanf("%d",&item);
for(i=1;i<=n;i++)
{if(item==a[i])
{flag=1;
break;}}
if(flag==0)
printf("\nElement not Found\n\n");
else
printf("\nElement %d found at position %d \n\n", item,i);

}







Binary Search(DATA,LB,UB,ITEM,LOC)
Here, DATA is a sorted array with lower bound LB and upper bound UB and ITEM is a given
item of information. The variables beg, end and mid denote beginning, end and middle locations of a
segment of elements of DATA. This algorithm finds the location LOC of ITEM in DATA or sets
LOC= NULL.
Step 1: [initialization] end;=ub, beg:=lb,
[obtain the index of middle value] mid = (beg+end)/2;
Step 2: [search for the item]
Repeat steps 3&amp;4 while big&lt;=end.
Step 3: [compare to search for item]
if(ITEM &lt; DATA[mid]) then set end:=mid-1
otherwise if( ITEM &gt; DATA[mid]) then set lb:=mid+1;
otherwise if(ITEM==DATA[mid]) Write :“match found” , Set LOC:=mid.
Step 4: Set mid:=INT((beg+end)/2)
Step5: [unsuccessful search] Write “match not found” and set LOC:=NULL
Step 6: [end of algorithm] Exit



program

BINARY SEARCH
#include<stdio.h>
void main()
{int a[20],i,n,beg,mid,end,item,loc=-1;
printf("\n Enter the number of elements in the list");
scanf("%d",&n);
printf(" \n Enter the elements in ascending order");
for(i=1;i<=n;i++)
{scanf("%d",&a[i]);}
printf("\n Enter the element to search");
scanf("%d",&item);
beg=1;
end=n;
while(beg<=end)
{mid=(beg+end)/2;
if(item==a[mid])
{ loc=mid;
break; }
else if(item>a[mid])
{beg=mid+1;}
else
{end=mid-1;}}
if(loc==-1)
printf("\nElement not Found \n\n");
else
printf("\n Element %d found at location %d \n\n",item,loc);}










p3
INSERT( ITEM)
[This algorithm adds newnodes at any position (Top, in Middle and atEnd) in the List ]
1. Create a New Node in memory
2. Set NewNode-&gt;INFO =ITEM. [Copies new data into INFO of new node.]
3. Set NewNode-&gt;NEXT = NULL. [Copies NULL in NEXT of new node.]
4. If HEAD=NULL, then HEAD=NewNode
and return. [Add first node in list]
5. if NewNode-&gt;INFO&lt;HEAD-&gt;INFO then Set NewNode-&gt;NEXT=HEAD and
HEAD=NewNode and return [Add node on top of existing list]
6. PrevNode = NULL, CurrNode=NULL;
7. for(CurrNode =HEAD; CurrNode != NULL; CurrNode =CurrNode-&gt;NEXT)
{ if(NewNode-&gt;INFO &lt;= CurrNode-&gt;INFO)
{break the loop}
PrevNode =CurrNode;}
[ end of loop ]
[Insert after PREV node (in middle or at end) of the list]
8. Set NewNode -&gt;NEXT = PrevNode-&gt;NEXT and
9. Set PrevNode-&gt;NEXT=NewNode.
10. Exit


program
#include<stdio.h>
#include<malloc.h>
#include<stdlib.h>
struct node
{int data;
struct node *next;}
*start=NULL;
void create()

{//char ch;
int k;
do
{ struct node *ptr;
struct node *current;
ptr=(struct node *)malloc(sizeof(struct node));
printf("\n\n Enter the data");
scanf("%d",&ptr->data);
ptr->next=NULL;
if(start==NULL)
{start=ptr;
current=ptr;}
else
{current->next=ptr;
current=ptr;}
printf("\n Do you want to create another? (1 for yes and 0 for no) ");
scanf("%d",&k);}
while(k!=0);}
void display()
{struct node *ptr;
printf("\n\nThe Linked List is :: ");
pt=start;
while(ptr!=NULL)
{printf("%d---->",ptr->data);
ptr=ptr->next;}
printf("NULL\n\n\n");}
void main()
{create();
display();}














p4
Push(S, TOP, X).
This procedure inserts an element X to the top of a stack which is represented by a vector S containing
N elements with a pointer TOP denoting the top element of the stack. The first step of this algorithm
checks for overflow condition. If such a condition exits then the insertion operation cannot be
performed.
1. [check for stack overflow]
If TOP&gt;=N
then
Write (“stack overflow”)
Return
2. [increment Top]
TOP=TOP+1
3. [insert element]
S[TOP]=X
4. [finished]
Return


Pop (S, TOP)
This function removes the top element from the stack which is represented by the vector S and returns
this element. TOPis a pointer to the top of the stack. An underflow condition is checked in the first
step .If there is an underflow then appropriate actions should take place.
1. [check for underflow of the stack]
If TOP =0 then
Write(“stack underflow on pop)
Exit
2. [decrement pointer]
TOP=TOP-1
3. [return former top element of the stack]
Return(S[TOP+1])



program
#include <stdio.h>
#define MAXSIZE 5
/* Structure definition for stack */
struct stack
{int stk[MAXSIZE];
int top;}s;
typedef struct stack STACK;
STACK s;
/* Function declaration/Prototype*/
void push (void);
int pop(void);
void display (void);
void main ()
{int choice;
int option = 1;
s.top = 0;
printf ("STACK OPERATION\n");
while(option)
{printf ("------------------------------------------\n");
printf (" 1 --> PUSH \n");
printf (" 2 --> POP \n");
printf (" 3 --> DISPLAY \n");

printf (" 4 --> EXIT \n");
printf ("------------------------------------------\n");
printf ("Enter your choice\n");
scanf ("%d", &choice);
switch (choice)
{case 1: push();
break;
case 2:pop();
break;
case 3:display();
break;
case 4:return;}
fflush(stdin);
printf("Do you want to continue(Type 1 for Yes or 0 for No)?\n");
scanf("%d", &option);}}
/*Function to add an element to the stack*/
void push ()
{int num;
if (s.top == (MAXSIZE))
{printf ("Stack is Full\n");
return;}
else
{printf ("Enter the element to be pushed\n");
scanf ("%d", &num);
s.top = s.top + 1;
s.stk[s.top] = num;}
return;}
/*Function to delete an element from the stack*/
int pop ()
{int num;
if (s.top == 0)
{printf ("Stack is Empty\n");
return (s.top);}
else
{num = s.stk[s.top];
printf ("poped element is = %d\n", s.stk[s.top]);
s.top = s.top - 1;}
return(num);}
/*Function to display the status of the stack*/
void display ()
{int i;
if (s.top == 0)
{printf ("Stack is empty\n");
return;}
else
{printf ("\nThe status of the stack is\n");
for (i = s.top; i > 0; i--)
{printf ("%d\n", s.stk[i]);}}
printf ("\n");}










p5
Algorithm to convert Infix To Postfix:

Let, X is an arithmetic expression written in infix notation. This algorithm finds the
equivalent postfix expression Y.
1. Push “(“onto Stack, and add “)” to the end of X.
2. Scan X from left to right and repeat Step 3 to 6 for each element of X until the Stack is empty.
3. If an operand is encountered, add it to Y.
4. If a left parenthesis is encountered, push it onto Stack.
5. If an operator is encountered ,then:
1. Repeatedly pop from Stack and add to Y each operator (on the top of Stack) which
has the same precedence as or higher precedence than operator.
2. Add operator to Stack.
[End of If]

6. If a right parenthesis is encountered ,then:
1. Repeatedly pop from Stack and add to Y each operator (on the top of Stack) until a
left parenthesis is encountered.
2. Remove the left Parenthesis.
[End of If]
[End of If]

7. END.



program
PRACTICAL 5

#include<stdio.h>
#include<ctype.h>
char stack[100];
int top = -1;
void push(char x)
{
stack[++top] = x;
}
char pop()
{
if(top == -1)
return -1;
else
return stack[top--];
}
int priority(char x)
{
if(x == '(')
return 0;
if(x == '+' || x == '-')
return 1;
if(x == '*' || x == '/')
return 2;
return 0;
}
int main()
{
char exp[100];
char *e, x;
printf("Enter the expression : ");
scanf("%s",exp);
printf("\n");
e = exp;
while(*e != '\0')
{
if(isalnum(*e))
printf("%c ",*e);
else if(*e == '(')
push(*e);
else if(*e == ')')
{
while((x = pop()) != '(')
printf("%c ", x);
}
else
{
while(priority(stack[top]) >= priority(*e))

printf("%c ",pop());
push(*e);
}
e++;
}
while(top != -1)
{
printf("%c ",pop());
}return 0;
}







p6
void towerOfHanoi(int n, char from_rod, char to_rod, char aux_rod)
{
if (n == 1)
{
printf("\n Move disk 1 from rod %c to rod %c", from_rod, to_rod);
return;
}
towerOfHanoi(n-1, from_rod, aux_rod, to_rod);
printf("\n Move disk %d from rod %c to rod %c", n, from_rod, to_rod);
towerOfHanoi(n-1, aux_rod, to_rod, from_rod);
}
int main()
{
int n = 4; // Number of disks
towerOfHanoi(n, \'A\', \'C\', \'B\'); // A, B and C are names of
rods
return 0;
}








PRACTICAL NO 7

#include<stdio.h>
typedef struct node
{ int data;
struct node *left;
struct node *right;}
node;
node *create()
{ node *p;
int x;
printf("Enter data(-1 for no data):");
scanf("%d",&x);
if(x==-1)
return NULL;
p=(node*)malloc(sizeof(node));
p->data=x;
printf("Enter left child of %d:\n",x);
p->left=create();
printf("Enter right child of %d:\n",x);

p->right=create();
return p;}
void preorder(node *t) //address of root node is passed in t
{if(t!=NULL)
{printf("\n%d",t->data); //visit the root
preorder(t->left); //preorder traversal on left subtree
preorder(t->right); //preorder traversal on right subtree }}
int main()
{node *root;
root=create();
printf("\nThe preorder traversal of tree is:\n");
preorder(root);
return 0;}










PRACTICAL 8
#include<stdio.h>
void quicksort(int [10],int,int);
int main(){
int x[20],size,i;
printf("\nEnter size of the array: ");
scanf("%d",&size);
printf("\nEnter %d elements: ",size);
for(i=0;i<size;i++)
scanf("%d",&x[i]);
quicksort(x,0,size-1);
printf("\nSorted elements: ");
for(i=0;i<size;i++)
printf(" %5d",x[i]);
printf("\n\n");
return 0;}
void quicksort(int x[10],int first,int last){
int pivot,j,temp,i;
if(first<last){
pivot=first;
i=first;
j=last;
while(i<j){
while(x[i]<=x[pivot]&&i<last)
i++;
while(x[j]>x[pivot])
j--;
if(i<j){
temp=x[i];
x[i]=x[j];
x[j]=temp;}}
temp=x[pivot];
x[pivot]=x[j];
x[j]=temp;
quicksort(x,first,j-1);

quicksort(x,j+1,last);}}

MERGE SORT
#include<stdio.h>
#define MAX 50
void mergeSort(int arr[],int low,int mid,int high);
void partition(int arr[],int low,int high);
int main()
{int merge[MAX],i,n;
printf("\nEnter the total number of elements: ");
scanf("%d",&n);
printf("\nEnter the elements which to be sort: ");
for(i=0;i<n;i++){
scanf("%d",&merge[i]);}
partition(merge,0,n-1);
printf("\nAfter merge sorting elements are: ");
for(i=0;i<n;i++){
printf("%d ",merge[i]);}
printf("\n\n");
return 0;}
void partition(int arr[],int low,int high){
int mid;
if(low<high){
mid=(low+high)/2;
partition(arr,low,mid);
partition(arr,mid+1,high);
mergeSort(arr,low,mid,high);}}
void mergeSort(int arr[],int low,int mid,int high){
int i,m,k,l,temp[MAX];
l=low;
i=low;
m=mid+1;
while((l<=mid)&&(m<=high)){
if(arr[l]<=arr[m]){
temp[i]=arr[l];
l++; }
else{
temp[i]=arr[m];
m++;}
i++; }
if(l>mid)
{for(k=m;k<=high;k++){
temp[i]=arr[k];
i++;}}
else{
for(k=l;k<=mid;k++){

temp[i]=arr[k];
i++; }}
for(k=low;k<=high;k++){
arr[k]=temp[k];}}
